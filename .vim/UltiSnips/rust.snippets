# ==============================================================================
# Functions
# ==============================================================================
snippet fn "function"
fn ${1:NAME}(${2:PARAMS}) `!p
if len(t[3]) > 0:
	snip.rv = "-> "
else:
	snip.rv = ""
`${3:RETURN_TYPE}`!p
if len(t[3]) != 0:
	snip.rv = " "
else:
	snip.rv = ""
`{
	$4
}
$0
endsnippet

# ==============================================================================
# Conditions
# ==============================================================================
snippet if "if" b
if ${1:CONDITION} {
	${2:${VISUAL}}
}
$0
endsnippet

snippet ife "if-else" b
if ${1:CONDITION} {
	${2:${VISUAL}}
} else {
	${3:ELSE-BLOCK}
}
$0
endsnippet

snippet ifl "if-let" b
if let ${1:PATTERN} = ${2:EXPRESSION} {
	${3:${VISUAL}}
}
$0
endsnippet

snippet ifle "if-let-else" b
if let ${1:PATTERN} = ${2:EXPRESSION} {
	${3:${VISUAL}}
} else {
	$4
}
$0
endsnippet

snippet match "match" b
match ${1:PATTERN} {
	${2:PATTERN} => ${3:EXPRESSION},
}
$0
endsnippet

# ==============================================================================
# Loops
# ==============================================================================
snippet while "while" b
while ${1:CONDITION} {
	${2:${VISUAL}}
}
$0
endsnippet

snippet for "for" b
for ${1:ELEMENT} in ${2:ITERATOR} {
	${3:${VISUAL}}
}
$0
endsnippet

# ==============================================================================
# Structs
# ==============================================================================
snippet enum "enum" b
enum ${1:NAME} {
	$2
}
$0
endsnippet

snippet struct "struct" b
#[derive(Debug, Clone, Default, PartialEq, Serialize, Deserialize)]
struct ${1:NAME} {
	$2
}
$0
endsnippet

snippet simpl "struct-implement" b
struct ${1:NAME} {
	$2
}

impl $1 {
	$3
}
$0
endsnippet

snippet trt "trait" b
impl ${1:TRAIT} for ${2:TYPE} {
	${3:${VISUAL}}
}
$0
endsnippet

# ==============================================================================
# Generics
# ==============================================================================
snippet opt "Option<T>"
Option<${1:TYPE}>$0
endsnippet

snippet res "Result<T, E>"
Result<${1:OK_TYPE}, ${2:ERROR_TYPE}>$0
endsnippet

# ==============================================================================
# Organisation
# ==============================================================================
snippet mod "module" b
mod ${1:MODULE_NAME} {
	${2:${VISUAL}}
}
$0
endsnippet

snippet test "unit tests" b
#[cfg(test)]
mod tests {
	use super::*;
	#[test]
	${1:fn it_works() {
		assert_eq!(2 + 2, 4);
	}}
}
endsnippet

# ==============================================================================
# Convenience
# ==============================================================================
snippet shutup "silence some warnings in vim" b
// TODO remove
#![allow(unused_macros)]
#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(unused_mut)]
endsnippet

# ==============================================================================
# Macros
# ==============================================================================
global !p
def complete(t, opts):
	if t:
		opts = [ m[len(t):] for m in opts if m.startswith(t) ]
	if len(opts) == 1:
		return opts[0]
	return '(' + '|'.join(opts) + ')'
endglobal

global !p
def completeMacroType(t):
	opts = [
		"expr",
		"ident",
		"item",
		"lifetime",
		"literal",
		"meta",
		"pat",
		"path",
		"stmt",
		"tt",
		"ty",
		"block",
		"vis"
	]
	return complete(t, opts)
endglobal

global !p
def completeMacroRep(t):
	opts = [
		"?",
		"*",
		"+",
		" "
	]
	return complete(t, opts)
endglobal

global !p
def completeMacroSep(t):
	opts = [
		",",
		";",
		" ",
		# "?",
		# "*",
		# "+",
	]
	return complete(t, opts)
endglobal

snippet macro "macro rules macro" b
macro_rules! ${1:macro_name} {
	( $($${2:var_name}:$3`!p snip.rv = completeMacroType(t[3])`))$5`!p snip.rv = completeMacroSep(t[5])`$6`!p snip.rv = completeMacroRep(t[6])` => {
		${7: // Implementation}
	},
	$0
}
endsnippet

# ================================== Utility =============================== {{{

snippet sleep "sleep" b
std::thread::sleep(std::time::Duration::${1:from_secs}(${2:DURATION}));$0
endsnippet

# }}}
