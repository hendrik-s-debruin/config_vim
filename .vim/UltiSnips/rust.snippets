# ==============================================================================
# Functions
# ==============================================================================
snippet fn "function"
fn ${1:NAME}(${2:PARAMS}) `!p
if len(t[3]) > 0:
	snip.rv = "-> "
else:
	snip.rv = ""
`${3:RETURN_TYPE}`!p
if len(t[3]) != 0:
	snip.rv = " "
else:
	snip.rv = ""
`{
	$4
}
$0
endsnippet

# ==============================================================================
# Conditions
# ==============================================================================
snippet if "if" b
if ${1:CONDITION} {
	${2:${VISUAL}}
}
$0
endsnippet

snippet ife "if-else" b
if ${1:CONDITION} {
	${2:${VISUAL}}
} else {
	${3:ELSE-BLOCK}
}
$0
endsnippet

snippet ifl "if-let" b
if let ${1:PATTERN} = ${2:EXPRESSION} {
	${3:${VISUAL}}
}
$0
endsnippet

snippet ifle "if-let-else" b
if let ${1:PATTERN} = ${2:EXPRESSION} {
	${3:${VISUAL}}
} else {
	$4
}
$0
endsnippet

snippet match "match" b
match ${1:PATTERN} {
	${2:PATTERN} => ${3:EXPRESSION},
}
$0
endsnippet

# ==============================================================================
# Loops
# ==============================================================================
snippet while "while" b
while ${1:CONDITION} {
	${2:${VISUAL}}
}
$0
endsnippet

snippet for "for" b
for ${1:ELEMENT} in ${2:ITERATOR} {
	${3:${VISUAL}}
}
$0
endsnippet

# ==============================================================================
# Structs
# ==============================================================================
snippet enum "enum" b
enum ${1:NAME} {
	$2
}
$0
endsnippet

snippet struct "struct" b
#[derive(Debug, Clone, Default, PartialEq, Serialize, Deserialize)]
struct ${1:NAME} {
	$2
}
$0
endsnippet

snippet simpl "struct-implement" b
struct ${1:NAME} {
	$2
}

impl $1 {
	$3
}
$0
endsnippet

snippet trt "trait" b
impl ${1:TRAIT} for ${2:TYPE} {
	${3:${VISUAL}}
}
$0
endsnippet

# ==============================================================================
# Generics
# ==============================================================================
snippet opt "Option<T>"
Option<${1:TYPE}>$0
endsnippet

snippet res "Result<T, E>"
Result<${1:OK_TYPE}, ${2:ERROR_TYPE}>$0
endsnippet

# ==============================================================================
# Organisation
# ==============================================================================
snippet mod "module" b
mod ${1:MODULE_NAME} {
	${2:${VISUAL}}
}
$0
endsnippet

snippet test "unit tests" b
#[cfg(test)]
mod tests {
	use super::*;
	#[test]
	${1:fn it_works() {
		assert_eq!(2 + 2, 4);
	}}
}
endsnippet

# ==============================================================================
# Convenience
# ==============================================================================
snippet shutup "silence some warnings in vim" b
// TODO remove
#![allow(unused_macros)]
#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(unused_mut)]
endsnippet

snippet strict "strict warnings" b
#![warn(
    clippy::all,
    // clippy::cargo,
    clippy::complexity,
    clippy::nursery,
    clippy::perf,
    clippy::style,
    clippy::suspicious,
)]
#![deny(clippy::pedantic)]
#![deny(
    clippy::alloc_instead_of_core,
    clippy::allow_attributes_without_reason,
    clippy::assertions_on_result_states,
    clippy::as_underscore,
    clippy::clone_on_ref_ptr,
    clippy::create_dir,
    clippy::dbg_macro,
    clippy::empty_drop,
    clippy::empty_structs_with_brackets,
    clippy::exit,
    clippy::expect_used,
    clippy::if_then_some_else_none,
    clippy::indexing_slicing,
    clippy::large_include_file,
    clippy::let_underscore_must_use,
    clippy::mem_forget,
    clippy::missing_docs_in_private_items,
    clippy::mixed_read_write_in_expression,
    clippy::multiple_inherent_impl,
    clippy::panic,
    clippy::panic_in_result_fn,
    clippy::partial_pub_fields,
    clippy::print_stderr,
    clippy::print_stdout,
    clippy::pub_use,
    clippy::rc_buffer,
    clippy::rc_mutex,
    clippy::same_name_method,
    clippy::std_instead_of_alloc,
    clippy::std_instead_of_core,
    clippy::string_slice,
    clippy::string_to_string,
    clippy::str_to_string,
    clippy::todo,
    clippy::try_err,
    clippy::unimplemented,
    clippy::unnecessary_self_imports,
    clippy::unreachable,
    clippy::unwrap_in_result,
    clippy::unwrap_used,
    clippy::use_debug,
    clippy::wildcard_enum_match_arm,
)]
#![allow(clippy::module_name_repetitions)]
#![cfg_attr(
    test,
    allow(clippy::expect_used),
    allow(clippy::missing_panics_doc),
    allow(clippy::multiple_inherent_impl),
    allow(clippy::panic),
    allow(clippy::unwrap_used),
    allow(clippy::panic_in_result_fn)
)]
endsnippet

# ==============================================================================
# Macros
# ==============================================================================
global !p
def complete(t, opts):
	if t:
		opts = [ m[len(t):] for m in opts if m.startswith(t) ]
	if len(opts) == 1:
		return opts[0]
	return '(' + '|'.join(opts) + ')'
endglobal

global !p
def completeMacroType(t):
	opts = [
		"expr",
		"ident",
		"item",
		"lifetime",
		"literal",
		"meta",
		"pat",
		"path",
		"stmt",
		"tt",
		"ty",
		"block",
		"vis"
	]
	return complete(t, opts)
endglobal

global !p
def completeMacroRep(t):
	opts = [
		"?",
		"*",
		"+",
		" "
	]
	return complete(t, opts)
endglobal

global !p
def completeMacroSep(t):
	opts = [
		",",
		";",
		" ",
		# "?",
		# "*",
		# "+",
	]
	return complete(t, opts)
endglobal

snippet macro "macro rules macro" b
macro_rules! ${1:macro_name} {
	( $($${2:var_name}:$3`!p snip.rv = completeMacroType(t[3])`))$5`!p snip.rv = completeMacroSep(t[5])`$6`!p snip.rv = completeMacroRep(t[6])` => {
		${7: // Implementation}
	},
	$0
}
endsnippet

# ================================== Utility =============================== {{{

snippet sleep "sleep" b
std::thread::sleep(std::time::Duration::${1:from_secs}(${2:DURATION}));$0
endsnippet

# }}}
